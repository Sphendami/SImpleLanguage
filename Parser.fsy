%{
open Language
%}
%token <string> VAR
%token FUN RARROW
%token LPAREN RPAREN
%token TRUE FALSE
%token IF THEN ELSE
%token <int> INTEGER
%token PLUS MINUS STAR SLASH
%token ANDAND PIPEPIPE
%token EQUAL LESSTHAN GREATERTHAN LESSTHANEQ GREATERTHANEQ
%token EOT
%nonassoc PLUS MINUS
%nonassoc STAR SLASH
%start main
%type <Language.Term> main
%%
atom:
    | TRUE {Boolean true}
    | FALSE {Boolean false}
    | INTEGER {Integer $1}
    | LPAREN term RPAREN {$2}
    | VAR {Var $1}
;
applist:
    | atom {$1}
    | applist atom {App ($1, $2)}
;
expr:
    | applist {$1}
    | expr PLUS expr {BinaryOp (Add, $1, $3)}
    | expr MINUS expr {BinaryOp (Sub, $1, $3)}
    | expr STAR expr {BinaryOp (Mul, $1, $3)}
    | expr SLASH expr {BinaryOp (Div, $1, $3)}
    | expr ANDAND expr {BinaryOp (And, $1, $3)}
    | expr PIPEPIPE expr {BinaryOp (Or, $1, $3)}
    | expr EQUAL expr {BinaryOp (Equal, $1, $3)}
    | expr LESSTHAN expr {BinaryOp (Lt, $1, $3)}
    | expr GREATERTHAN expr {BinaryOp (Gt, $1, $3)}
    | expr LESSTHANEQ expr {BinaryOp (Lte, $1, $3)}
    | expr GREATERTHANEQ expr {BinaryOp (Gte, $1, $3)}
;
term:
    | expr {$1}
    | FUN term RARROW term {
        let arg =
            match $2 with
            | Var s -> s
            | _ -> failwith "parse error"
        Abs (arg, $4)
    }
    | IF term THEN term ELSE term {If ($2, $4, $6)}
;
main:
    term EOT {$1}
;